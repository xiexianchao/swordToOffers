#### 给出一个数组，求股票的最大利润，要求必须卖出才能接着买入

LeetCode121 只可买卖一次，求最大利润 price[i] - minInput(0,i-1) 就可求出i处的最大利润

LeetCode122 可多次买卖求最大利润   即求 diff = price[i] - price[i-1] sum += (diff>0?diff:0)

LeetCode123 最多买卖两次求最大利润     //动态规划
                          
                              /*
                          Buy1[i]表示前i天做第一笔交易买入股票后剩下的最多的钱；
                          
                          Sell1[i]表示前i天做第一笔交易卖出股票后剩下的最多的钱；
                          
                          Buy2[i]表示前i天做第二笔交易买入股票后剩下的最多的钱；
                          
                          Sell2[i]表示前i天做第二笔交易卖出股票后剩下的最多的钱；
                          
                          那么：
                          
                          Sell2[i]=max{Sell2[i-1],Buy2[i-1]+prices[i]}
                          Buy2[i]=max{Buy2[i-1],Sell[i-1]-prices[i]}
                          Sell1[i]=max{Sell[i-1],Buy1[i-1]+prices[i]}
                          Buy1[i]=max{Buy[i-1],-prices[i]}
                               *
                               */
LeetCode188 最多可以买卖k次求最大利润       
/* 典型的动态规划，并且利用局部和全局最优，这种思想值得仔细体会，好好掌握。   
 这种局部最优与全局最优问题    
 global[i][j] = max(local[i][j], global[i - 1][j])    
 很容易知道上面这个递推式。    
 关键在于求取局部最优的递推式，在本题中    
 local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)    
 这里我们需要两个递推公式来分别更新两个变量local和global    
 我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优    
 局部最优解的递推式可以这样理解：    
 在i-1天时，正在进行第j次交易，所以我们最后一天必须将股票卖出，而且这是算在第j次交易当中的，这种情况下，local[i - 1][j] + diff，只需将i-1天的局部最优解加上最后一天卖出的差值即可，相当于将最后一次交易多延迟了一天    
 第二种情况，就是在第i-1天进行j-1次交易的全局最优解，我们在最后一天还得进行一次交易，必须卖出，如果diff大于0，那么就在第i-1天买进，i天卖出，如果小于0，就直接在第i天买进又卖出，只是为了满足j次交易，就相当于没有交易，即加上0就可以了。    
 这道题还有一个陷阱，可以优化的地方，就是如果k>=prices.length/2。那我们可以理解可以进行任意次交易了，因为有效交易都需要两天来完成，所以直接使用贪心法就可以算出来了。    
 */

后面两种比较麻烦，前一个是后一个的特例。    
 
LeetCode714 Best Time to Buy and Sell Stock with Transaction Fee 可以任意次买卖，但是每次买卖需要手续费fee，求最大利润      
对于某一天，考虑当天持有彩票，和不持有彩票两种情况。   
dp[i][0] 表示第i天不持有彩票最大利润     dp[i][1]表示第i天持有彩票利润    
dp[i][0] = Math.max(dp[i-1][0],dp[i][1] + prices[i] - fee) 第i天不持有彩票的情况是对第i-1天不持有彩票，第i-1天持有彩票，但第i天卖出求最大值      
dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]);
dp[0][0] = 0, dp[0][1] = -prices[0]  