### 动态规划
动态规划一般是局部最优解然后去得到全局最优解问题。

1.股票问题

2. LeetCode338 Counting Bits   求0-numm 之间每个元素二进制中1的个数    
bitArray[n] = bitArray[n >>> 1] + ( n & 1 );   

3. LeetCode413  Arithmetic Slices  

4. LeetCode647 Palindromic Substrings  求最长回文子串   

5. LeetCode712 Minimum ASCII Delete Sum for Two Strings 给出两个字符串，删除其中元素两个字符串相等，求删除元素的最小和
这种dp思想在股票的最大利润中也出现过，  dp[i][j] 表示s1(i:),s2(j:)满足条件的最小值    
int[][] dp = new int[s1.length()+1][s2.length()+1];    
则：  
当j = s2.length()时,dp[i][s2.length()] = dp[i+1][s2.length()] + s1.charAt(i);     
当i = s1.length()时,dp[s1.length()][j] = dp[s1.length()][j+1] + s2.charAt(j)    
其它情况下:    
当s1.charAt(i) = s2.charAt(j)时，dp[i][j] = dp[i+1][j+1];     
else 就要去掉s1[i],s2[j]中的一个，dp[i][j] = Math.min(dp[i+1][j]+s1.charAt(i),dp[i][j+1]+ s2.charAt(j));
  
6. 714 Best Time to Buy and Sell Stock with Transaction Fee 股票的最大利润     
对于某一天，考虑当天持有彩票，和不持有彩票两种情况。    
   
dp[i][0] 表示第i天不持有彩票最大利润     dp[i][1]表示第i天持有彩票利润    
dp[i][0] = Math.max(dp[i-1][0],dp[i][1] + prices[i] - fee) 第i天不持有彩票的情况是对第i-1天不持有彩票，第i-1天持有彩票，但第i天卖出求最大值      
dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]);
dp[0][0] = 0, dp[0][1] = -prices[0]  
  

7. LeetCode931 Minimum Falling Path Sum 求最小的下降路径    

8. LeetCode646  Maximum Length of Pair Chain   
这道题，我第一想到就是用全排列来做，然而也猜到了会报Time Limit Exceeded，因为没有从分利用 
题干，pairs[i][1] > pairs[i][0]这个条件 。     
用dp来做，显然要一开始对原数组进行排序，排序规则要按照pairs[i][0]来进行排序，貌似答案并没有考虑
如果pairs[i][0]=pairs[j][0]，但是pairs[i][1] != pairs[j][1]的情况    
整理一个答案的思路：先对pairs进行排序，dp[i]表示以pairs[i]结尾的链的长度    
如果存在pairs[i][1] < pairs[j][0]，这里有个隐形条件i<j，会有dp[j] = Math.max(dp[j],dp[i]+1);    
遍历一开始的时候dp[i] = 1    
dp[0] 永远都等于1。     